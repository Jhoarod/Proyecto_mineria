round(avg_sil_hc, 3),
ifelse(exists("avg_sil_dbscan"), round(avg_sil_dbscan, 3), NA),
ifelse(exists("avg_sil_ms"), round(avg_sil_ms, 3), NA)
),
Características = c(
"Rápido, requiere k predefinido",
"Estructura jerárquica, dendrograma",
"Detecta formas irregulares y ruido",
"Encuentra clusters por densidad"
)
)
# Asignar clusters según el mejor método (se guarda en DataLimpia para compatibilidad)
if(best_method == "K-Means") {
DataLimpia$cluster_risk <- as.factor(kmeans_model$cluster)
} else if(best_method == "Jerárquico (Ward)") {
DataLimpia$cluster_risk <- as.factor(hc_clusters)
} else if(best_method == "DBSCAN") {
DataLimpia$cluster_risk <- as.factor(dbscan_model$cluster)
} else {
DataLimpia$cluster_risk <- as.factor(ms_clusters)
}
# Calcular perfil de cada cluster usando variables originales de DataLimpia
cluster_profiles <- DataLimpia %>%
filter(as.numeric(as.character(cluster_risk)) > 0) %>%  # Excluir ruido
group_by(cluster_risk) %>%
summarise(
n = n(),
mean_elevation = mean(elevation_m, na.rm = TRUE),
mean_rainfall = mean(historical_rainfall_intensity_mm_hr, na.rm = TRUE),
mean_drainage_prox = mean(storm_drain_proximity_m, na.rm = TRUE),
.groups = 'drop'
) %>%
mutate(
# Score de riesgo: menor elevación + mayor lluvia + mayor distancia = más riesgo
risk_score = (1 - scale(mean_elevation)[,1]) * 0.4 +
scale(mean_rainfall)[,1] * 0.4 +
scale(mean_drainage_prox)[,1] * 0.2
) %>%
arrange(risk_score)
best_method <- "K-Means"
if(best_method == "K-Means") {
DataLimpia$Cluster_risk <- as.factor(kmeans_model$cluster)
} else if(best_method == "Jerárquico (Ward)") {
DataLimpia$Cluster_risk <- as.factor(hc_clusters)
} else if(best_method == "DBSCAN") {
DataLimpia$Cluster_risk <- as.factor(dbscan_model$cluster)
} else {
DataLimpia$Cluster_risk <- as.factor(ms_clusters)
}
# Calcular perfil de cada cluster usando variables originales de DataLimpia
cluster_profiles <- DataLimpia %>%
filter(as.numeric(as.character(cluster_risk)) > 0) %>%  # Excluir ruido
group_by(cluster_risk) %>%
summarise(
n = n(),
mean_elevation = mean(elevation_m, na.rm = TRUE),
mean_rainfall = mean(historical_rainfall_intensity_mm_hr, na.rm = TRUE),
mean_drainage_prox = mean(storm_drain_proximity_m, na.rm = TRUE),
.groups = 'drop'
) %>%
mutate(
# Score de riesgo: menor elevación + mayor lluvia + mayor distancia = más riesgo
risk_score = (1 - scale(mean_elevation)[,1]) * 0.4 +
scale(mean_rainfall)[,1] * 0.4 +
scale(mean_drainage_prox)[,1] * 0.2
) %>%
arrange(risk_score)
library(ggplot2)
ggplot(DataLimpia, aes(x = elevation_m, y = historical_rainfall_intensity_mm_hr, color = risk_level)) +
geom_point() +
labs(title = "Distribución de Riesgo de Inundación por Clúster",
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)") +
theme_minimal()
# Calcular estadísticas por cluster usando las variables normalizadas
cluster_stats <- DataTransform %>%
group_by(Cluster) %>%
summarise(
n = n(),
elevacion_promedio = mean(norm_elevation_m, na.rm = TRUE),
lluvia_promedio = mean(norm_historical_rainfall_intensity_mm_hr, na.rm = TRUE),
proximidad_drenaje_promedio = mean(norm_storm_drain_proximity_m, na.rm = TRUE),
densidad_drenaje_promedio = mean(norm_drainage_density_km_per_km2, na.rm = TRUE),
periodo_retorno_promedio = mean(norm_return_period_years, na.rm = TRUE),
# También las variables derivadas
elevation_rain_ratio_promedio = mean(elevation_rain_ratio, na.rm = TRUE),
drainage_rain_index_promedio = mean(drainage_rain_index, na.rm = TRUE),
proximity_index_promedio = mean(proximity_index, na.rm = TRUE),
.groups = 'drop'
)
# Verificar que tenemos el mismo número de filas
cat("Filas en data_scaled:", nrow(data_scaled), "\n")
cat("Filas en DataTransform:", nrow(DataTransform), "\n")
cat("Filas en DataLimpia:", nrow(DataLimpia), "\n")
# Asignar clusters a ambos datasets
DataTransform$Cluster <- as.factor(kmeans_model$cluster)
DataLimpia$Cluster <- as.factor(kmeans_model$cluster)
# Verificar la asignación
cat("Clusters asignados correctamente\n")
print(table(DataTransform$Cluster))
# Calcular estadísticas por cluster usando las variables normalizadas
cluster_stats <- DataTransform %>%
group_by(Cluster) %>%
summarise(
n = n(),
elevacion_promedio = mean(norm_elevation_m, na.rm = TRUE),
lluvia_promedio = mean(norm_historical_rainfall_intensity_mm_hr, na.rm = TRUE),
proximidad_drenaje_promedio = mean(norm_storm_drain_proximity_m, na.rm = TRUE),
densidad_drenaje_promedio = mean(norm_drainage_density_km_per_km2, na.rm = TRUE),
periodo_retorno_promedio = mean(norm_return_period_years, na.rm = TRUE),
# También las variables derivadas
elevation_rain_ratio_promedio = mean(elevation_rain_ratio, na.rm = TRUE),
drainage_rain_index_promedio = mean(drainage_rain_index, na.rm = TRUE),
proximity_index_promedio = mean(proximity_index, na.rm = TRUE),
.groups = 'drop'
)
cat("\n========== ESTADÍSTICAS POR CLUSTER ==========\n")
print(cluster_stats)
# Crear índice de riesgo compuesto para cada cluster
cluster_stats <- cluster_stats %>%
mutate(
# Índice de riesgo usando variables normalizadas y derivadas
# Las variables ya están normalizadas (0-1)
risk_index = (1 - elevacion_promedio) * 0.30 +        # Elevación baja aumenta riesgo
lluvia_promedio * 0.25 +                  # Lluvia alta aumenta riesgo
proximidad_drenaje_promedio * 0.20 +      # Lejos de drenaje aumenta riesgo
(1 - drainage_rain_index_promedio) * 0.15 + # Bajo índice drenaje-lluvia aumenta riesgo
(1 - proximity_index_promedio) * 0.10     # Bajo índice proximidad aumenta riesgo
) %>%
arrange(desc(risk_index))
cat("\n========== ÍNDICE DE RIESGO POR CLUSTER ==========\n")
print(cluster_stats %>% select(Cluster, risk_index))
# Asignar nivel de riesgo según el índice
cluster_stats <- cluster_stats %>%
mutate(
risk_level = case_when(
risk_index >= quantile(risk_index, 0.67) ~ "Alto",
risk_index >= quantile(risk_index, 0.33) ~ "Medio",
TRUE ~ "Bajo"
)
)
cat("\n========== PERFILES DE RIESGO POR CLUSTER ==========\n")
print(cluster_stats %>% select(Cluster, risk_index, risk_level,
elevacion_promedio, lluvia_promedio,
proximidad_drenaje_promedio,
elevation_rain_ratio_promedio))
# Mapear niveles de riesgo a ambos datasets
risk_mapping <- setNames(cluster_stats$risk_level, cluster_stats$Cluster)
DataTransform$risk_level <- risk_mapping[as.character(DataTransform$Cluster)]
DataLimpia$risk_level <- risk_mapping[as.character(DataLimpia$Cluster)]
# Convertir a factor con niveles ordenados
DataTransform$risk_level <- factor(DataTransform$risk_level,
levels = c("Bajo", "Medio", "Alto"))
DataLimpia$risk_level <- factor(DataLimpia$risk_level,
levels = c("Bajo", "Medio", "Alto"))
cat("\n========== MAPEO COMPLETADO ==========\n")
cat("Niveles de riesgo asignados a DataTransform y DataLimpia\n")
# Distribución final
cat("\n========== DISTRIBUCIÓN FINAL POR NIVEL DE RIESGO ==========\n")
print(table(DataLimpia$risk_level))
cat("\nPorcentajes:\n")
print(round(prop.table(table(DataLimpia$risk_level)) * 100, 2))
# Visualización 1: Distribución de riesgo (Elevación vs Lluvia)
ggplot(DataLimpia, aes(x = elevation_m, y = historical_rainfall_intensity_mm_hr,
color = risk_level)) +
geom_point(alpha = 0.6, size = 1.5) +
scale_color_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Distribución de Riesgo de Inundación por Cluster",
subtitle = "K-Means con k=3",
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)",
color = "Nivel de Riesgo") +
theme_minimal() +
theme(legend.position = "right",
plot.title = element_text(face = "bold", size = 14))
# Visualización 2: Boxplots comparativos
DataLimpia %>%
select(risk_level, elevation_m, historical_rainfall_intensity_mm_hr,
drainage_density_km_per_km2, storm_drain_proximity_m) %>%
pivot_longer(cols = -risk_level, names_to = "variable", values_to = "value") %>%
ggplot(aes(x = risk_level, y = value, fill = risk_level)) +
geom_boxplot(alpha = 0.7) +
facet_wrap(~variable, scales = "free_y", ncol = 2,
labeller = labeller(variable = c(
"elevation_m" = "Elevación (m)",
"historical_rainfall_intensity_mm_hr" = "Intensidad lluvia (mm/hr)",
"drainage_density_km_per_km2" = "Densidad drenaje (km/km²)",
"storm_drain_proximity_m" = "Proximidad drenaje (m)"
))) +
scale_fill_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Comparación de Variables por Nivel de Riesgo",
x = "Nivel de Riesgo",
y = "Valor") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold", size = 14),
strip.text = element_text(face = "bold"))
# Visualización 3: Barras de distribución
ggplot(DataLimpia, aes(x = risk_level, fill = risk_level)) +
geom_bar(alpha = 0.8) +
geom_text(stat = 'count', aes(label = after_stat(count)),
vjust = -0.5, size = 4, fontface = "bold") +
scale_fill_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Distribución de Registros por Nivel de Riesgo",
x = "Nivel de Riesgo",
y = "Cantidad de registros") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold", size = 14))
# ESTADÍSTICAS FINALES POR NIVEL DE RIESGO
cat("\n========== ESTADÍSTICAS DESCRIPTIVAS POR NIVEL DE RIESGO ==========\n")
# Estadísticas usando datos originales de DataLimpia
stats_finales <- DataLimpia %>%
group_by(risk_level) %>%
summarise(
n = n(),
porcentaje = round(n() / nrow(DataLimpia) * 100, 2),
elevacion_media = round(mean(elevation_m, na.rm = TRUE), 2),
elevacion_sd = round(sd(elevation_m, na.rm = TRUE), 2),
lluvia_media = round(mean(historical_rainfall_intensity_mm_hr, na.rm = TRUE), 2),
lluvia_sd = round(sd(historical_rainfall_intensity_mm_hr, na.rm = TRUE), 2),
proximidad_drenaje_media = round(mean(storm_drain_proximity_m, na.rm = TRUE), 2),
densidad_drenaje_media = round(mean(drainage_density_km_per_km2, na.rm = TRUE), 2),
.groups = 'drop'
)
print(stats_finales)
# Estadísticas usando variables transformadas de DataTransform
cat("\n========== ESTADÍSTICAS CON VARIABLES NORMALIZADAS Y DERIVADAS ==========\n")
stats_transform <- DataTransform %>%
group_by(risk_level) %>%
summarise(
n = n(),
elevacion_norm_media = round(mean(norm_elevation_m, na.rm = TRUE), 3),
lluvia_norm_media = round(mean(norm_historical_rainfall_intensity_mm_hr, na.rm = TRUE), 3),
elevation_rain_ratio_media = round(mean(elevation_rain_ratio, na.rm = TRUE), 3),
drainage_rain_index_media = round(mean(drainage_rain_index, na.rm = TRUE), 3),
proximity_index_media = round(mean(proximity_index, na.rm = TRUE), 3),
.groups = 'drop'
)
print(stats_transform)
cat("\n========== ANÁLISIS DE CLUSTERING COMPLETADO ==========\n")
cat("Método utilizado: K-Means (k=3)\n")
cat("Coeficiente de Silueta:", round(avg_sil_kmeans, 3), "\n")
cat("Varianza explicada (BSS/TSS):", round(kmeans_model$betweenss / kmeans_model$totss * 100, 2), "%\n")
library(ggplot2)
ggplot(DataLimpia, aes(x = elevation_m, y = historical_rainfall_intensity_mm_hr, color = risk_level)) +
geom_point() +
labs(title = "Distribución de Riesgo de Inundación por Clúster",
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)") +
theme_minimal()
# Gráfico principal de distribución de riesgo
ggplot(DataLimpia %>% filter(risk_level != "Sin clasificar"),
aes(x = elevation_m, y = historical_rainfall_intensity_mm_hr,
color = risk_level)) +
geom_point(alpha = 0.6) +
scale_color_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = paste("Distribución de Riesgo de Inundación -", best_method),
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)") +
theme_minimal() +
theme(legend.position = "right")
# Boxplot comparativo por variable
DataLimpia %>%
filter(risk_level != "Sin clasificar") %>%
select(risk_level, elevation_m, historical_rainfall_intensity_mm_hr,
drainage_density_km_per_km2, storm_drain_proximity_m) %>%
pivot_longer(cols = -risk_level, names_to = "variable", values_to = "value") %>%
ggplot(aes(x = risk_level, y = value, fill = risk_level)) +
geom_boxplot() +
facet_wrap(~variable, scales = "free_y", ncol = 2) +
scale_fill_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Comparación de Variables por Nivel de Riesgo",
x = "Nivel de Riesgo", y = "Valor") +
theme_minimal() +
theme(legend.position = "none")
# Boxplot comparativo por variable
DataLimpia %>%
filter(risk_level != "Sin clasificar") %>%
select(risk_level, elevation_m, historical_rainfall_intensity_mm_hr,
drainage_density_km_per_km2, storm_drain_proximity_m) %>%
pivot_longer(cols = -risk_level, names_to = "variable", values_to = "value") %>%
ggplot(aes(x = risk_level, y = value, fill = risk_level)) +
geom_boxplot() +
facet_wrap(~variable, scales = "free_y", ncol = 2) +
scale_fill_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Comparación de Variables por Nivel de Riesgo",
x = "Nivel de Riesgo", y = "Valor") +
theme_minimal() +
theme(legend.position = "none")
# Estadísticas descriptivas por nivel de riesgo
cat("\n========== ESTADÍSTICAS POR NIVEL DE RIESGO ==========\n")
DataLimpia %>%
filter(risk_level != "Sin clasificar") %>%
group_by(risk_level) %>%
summarise(
n = n(),
elevacion_promedio = round(mean(elevation_m, na.rm = TRUE), 2),
lluvia_promedio = round(mean(historical_rainfall_intensity_mm_hr, na.rm = TRUE), 2),
proximidad_drenaje = round(mean(storm_drain_proximity_m, na.rm = TRUE), 2),
.groups = 'drop'
) %>%
print()
cat("\n========== ANÁLISIS DE CLUSTERING COMPLETADO ==========\n")
install.packages('tinytex')
install.packages("tinytex")
library(formattable)
library(dplyr)
library(tidyverse)
library(readr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
library(cluster)
library(factoextra)
library(caret)
library(randomForest)
library(fastDummies)
library(DescTools)
library(dbscan)
tinytex::uninstall_tinytex()
tinytex::install_tinytex()
tinytex:::is_tinytex()
tinytex::install_tinytex()
tinytex:::is_tinytex()
library(tinytex)
tinytex:::is_tinytex()
knitr::opts_chunk$set(echo = TRUE)
head(DataLimpia %>% select(elevation_m, drainage_density_km_per_km2))
knitr::opts_chunk$set(echo = TRUE)
library(formattable)
library(dplyr)
library(tidyverse)
library(readr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
library(cluster)
library(factoextra)
library(caret)
library(randomForest)
library(fastDummies)
library(DescTools)
library(tinytex)
library(gridExtra)
Data <- read.csv(
"urban_pluvial_flood_risk_dataset.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
# Selección de variables relevantes
DataSeleccion <- Data %>%
select(
elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_m,
historical_rainfall_intensity_mm_hr,
return_period_years,
land_use,
soil_group,
storm_drain_type
)
# Eliminación de registros (filas) con más del 30% de valores NA
DataLimpia <- DataSeleccion %>%
filter(if_all(everything(), ~ !is.na(.)))
# Mostrar cantidad de filas antes y después
nrow(DataSeleccion)
nrow(DataLimpia)
DataLimpia<- DataLimpia %>%
distinct()
# Detección de outliers por Z-score
z_scores <- scale(DataLimpia[, sapply(DataLimpia, is.numeric)])
outliers <- which(abs(z_scores) > 3, arr.ind = TRUE)
# Visualización de posibles outliers
boxplot(DataLimpia$historical_rainfall_intensity_mm_hr, main="Outliers en intensidad de lluvia")
boxplot(DataLimpia$storm_drain_proximity_m,
main = "Boxplot de Distancia a Drenaje (storm_drain_proximity_m)")
#  Eliminar elevaciones negativas
DataLimpia <- DataLimpia[DataLimpia$elevation_m >= 0, ]
#winsorización en la columna de lluvia histórica en una variable nueva rainfall_winsorizada
DataLimpia$rainfall_winsorizada <- DescTools::Winsorize(
DataLimpia$historical_rainfall_intensity_mm_hr,
val = quantile(
DataLimpia$historical_rainfall_intensity_mm_hr,
probs = c(0.01, 0.99),
na.rm = TRUE
)
)
#winsorización en la columna de lluvia histórica en una variable nueva  rainfall_winsorizada
DataLimpia$storm_drain_proximity_winsorizada <- DescTools::Winsorize(
DataLimpia$storm_drain_proximity_m,
val = quantile(
DataLimpia$storm_drain_proximity_m,
probs = c(0.01, 0.99),
na.rm = TRUE
)
)
DataTransform <- DataLimpia %>%
mutate(across(c(elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_m,
historical_rainfall_intensity_mm_hr,
return_period_years),
~ (.-min(.)) / (max(.)-min(.)),
.names = "norm_{col}"))
DataTransform <- fastDummies::dummy_cols(DataTransform,
select_columns = c("land_use", "soil_group", "storm_drain_type"),
remove_first_dummy = TRUE,
remove_selected_columns = TRUE)
DataTransform <- DataTransform %>%
mutate(
elevation_rain_ratio = norm_elevation_m / (norm_historical_rainfall_intensity_mm_hr + 0.001),
drainage_rain_index = norm_drainage_density_km_per_km2 * norm_historical_rainfall_intensity_mm_hr,
proximity_index = 1 / (norm_storm_drain_proximity_m + 0.01)
)
knitr::opts_chunk$set(echo = TRUE)
library(formattable)
library(dplyr)
library(tidyverse)
library(readr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
library(cluster)
library(factoextra)
library(caret)
library(randomForest)
library(fastDummies)
library(DescTools)
library(tinytex)
library(gridExtra)
Data <- read.csv(
"urban_pluvial_flood_risk_dataset.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
# Selección de variables relevantes
DataSeleccion <- Data %>%
select(
elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_m,
historical_rainfall_intensity_mm_hr,
return_period_years,
land_use,
soil_group,
storm_drain_type
)
# Eliminación de registros (filas) con más del 30% de valores NA
DataLimpia <- DataSeleccion %>%
filter(if_all(everything(), ~ !is.na(.)))
# Mostrar cantidad de filas antes y después
nrow(DataSeleccion)
nrow(DataLimpia)
DataLimpia<- DataLimpia %>%
distinct()
# Detección de outliers por Z-score
z_scores <- scale(DataLimpia[, sapply(DataLimpia, is.numeric)])
outliers <- which(abs(z_scores) > 3, arr.ind = TRUE)
# Visualización de posibles outliers
boxplot(DataLimpia$historical_rainfall_intensity_mm_hr, main="Outliers en intensidad de lluvia")
boxplot(DataLimpia$storm_drain_proximity_m,
main = "Boxplot de Distancia a Drenaje (storm_drain_proximity_m)")
#  Eliminar elevaciones negativas
DataLimpia <- DataLimpia[DataLimpia$elevation_m >= 0, ]
#winsorización en la columna de lluvia histórica en una variable nueva rainfall_winsorizada
DataLimpia$rainfall_winsorizada <- DescTools::Winsorize(
DataLimpia$historical_rainfall_intensity_mm_hr,
val = quantile(
DataLimpia$historical_rainfall_intensity_mm_hr,
probs = c(0.01, 0.99),
na.rm = TRUE
)
)
#winsorización en la columna de lluvia histórica en una variable nueva  rainfall_winsorizada
DataLimpia$storm_drain_proximity_winsorizada <- DescTools::Winsorize(
DataLimpia$storm_drain_proximity_m,
val = quantile(
DataLimpia$storm_drain_proximity_m,
probs = c(0.01, 0.99),
na.rm = TRUE
)
)
DataTransform <- DataLimpia %>%
mutate(across(c(elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_m,
historical_rainfall_intensity_mm_hr,
return_period_years),
~ (.-min(.)) / (max(.)-min(.)),
.names = "norm_{col}"))
DataTransform <- fastDummies::dummy_cols(DataTransform,
select_columns = c("land_use", "soil_group", "storm_drain_type"),
remove_first_dummy = TRUE,
remove_selected_columns = TRUE)
DataTransform <- DataTransform %>%
mutate(
elevation_rain_ratio = norm_elevation_m / (norm_historical_rainfall_intensity_mm_hr + 0.001),
drainage_rain_index = norm_drainage_density_km_per_km2 * norm_historical_rainfall_intensity_mm_hr,
proximity_index = 1 / (norm_storm_drain_proximity_m + 0.01)
)
head(DataLimpia %>% select(elevation_m, drainage_density_km_per_km2))
head(DataTransform %>% select(norm_elevation_m, norm_drainage_density_km_per_km2, elevation_rain_ratio))
