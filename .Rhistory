knitr::opts_chunk$set(echo = TRUE)
Data <- read.csv("urban_pluvial_flood_risk_dataset.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
View(Data)
install.packages("tidyverse")
install.packages("tidyverse")
install.packages("formattable")
install.packages("formattable")
install.packages("dplyr")
install.packages("readr")
install.packages("ggplot2")
install.packages("scales")
install.packages("knitr")
install.packages("knitr")
install.packages("kableExtra")
install.packages("kableExtra")
knitr::opts_chunk$set(echo = TRUE)
library(formattable)
library(dplyr)
library(tidyverse)
library(readr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
library(formattable)
library(dplyr)
library(tidyverse)
library(readr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
Data <- read.csv("urban_pluvial_flood_risk_dataset.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
# Selección de variables relevantes
DataSeleccion <- Data %>%
select(
elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_m,
historical_rainfall_intensity_mm_hr,
return_period_years,
land_use,
soil_group,
storm_drain_type
)
# Eliminación de valores faltantes
DataLimpia <- na.omit(DataSeleccion)
nrow(DataSeleccion)
nrow(DataLimpia)
DataLimpia <- DataSeleccion %>%
select(where(~ mean(is.na(.)) < 0.3))
# Eliminación de duplicados
DataLimpia<- DataLimpia %>%
distinct()
# Detección de outliers por Z-score
z_scores <- scale(DataLimpia[, sapply(DataLimpia, is.numeric)])
outliers <- which(abs(z_scores) > 3, arr.ind = TRUE)
# Visualización de posibles outliers
boxplot(DataLimpia$historical_rainfall_intensity_mm_hr, main="Outliers en intensidad de lluvia")
glimpse(DataLimpia)
install.packages("cluster")
install.packages("factoextra")
install.packages("caret")
install.packages("randomForest")
data_cluster <- DataLimpia %>%
select(land_use, soil_group, storm_drain_type, avg_rainfall, slope, flood_history)
View(DataLimpia)
View(DataLimpia)
data_cluster <- DataLimpia %>%
select(land_use, soil_group, storm_drain_type, slope, flood_history)
data_cluster <- DataLimpia %>%
select(elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_m,
historical_rainfall_intensity_mm_hr,
return_period_years,
land_use,
soil_group,
storm_drain_type)
# Convertir variables categóricas a numéricas si es necesario
data_cluster <- data_cluster %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(where(is.factor), as.numeric))
# Escalamiento (muy importante)
data_scaled <- scale(data_cluster)
# 2.1 Determinar número óptimo de clusters con el método del codo
fviz_nbclust(data_scaled, kmeans, method = "wss")
install.packages("factoextra")
install.packages("factoextra")
# 2.1 Determinar número óptimo de clusters con el método del codo
fviz_nbclust(data_scaled, kmeans, method = "wss")
library(formattable)
library(dplyr)
library(tidyverse)
library(readr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
library(cluster)
library(factoextra)
library(caret)
library(randomForest)
# Asignamos nombres a los clusters según el promedio de inundaciones
risk_labels <- Datin %>%
group_by(cluster_risk) %>%
summarise(mean_flood = mean(flood_history)) %>%
arrange(mean_flood)
# 2.1 Determinar número óptimo de clusters con el método del codo
fviz_nbclust(data_scaled, kmeans, method = "wss")
DataLimpia <- DataSeleccion %>%
filter(if_all(everything(), ~ !is.na(.)))
# 2.1 Determinar número óptimo de clusters con el método del codo
fviz_nbclust(data_scaled, kmeans, method = "wss")
data_cluster <- DataLimpia %>%
select(elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_m,
historical_rainfall_intensity_mm_hr,
return_period_years,
land_use,
soil_group,
storm_drain_type)
# Convertir variables categóricas a numéricas si es necesario
data_cluster <- data_cluster %>%
mutate(across(where(is.character), as.factor)) %>%
mutate(across(where(is.factor), as.numeric))
# Escalamiento (muy importante)
data_scaled <- scale(data_cluster)
# 2.1 Determinar número óptimo de clusters con el método del codo
fviz_nbclust(data_scaled, kmeans, method = "wss")
# 2.2 Probar K-Means con k = 3 (o el valor que el gráfico indique)
set.seed(123)
kmeans_model <- kmeans(data_scaled, centers = 3, nstart = 25)
# 2.3 Añadir los clusters al dataset original
Datin$cluster_risk <- as.factor(kmeans_model$cluster)
# 2.1 Determinar número óptimo de clusters con el método del codo
fviz_nbclust(data_scaled, kmeans, method = "wss")
# 2.2 Probar K-Means con k = 3 (o el valor que el gráfico indique)
set.seed(123)
kmeans_model <- kmeans(data_scaled, centers = 3, nstart = 25)
# 2.3 Añadir los clusters al dataset original
DataLimpia$cluster_risk <- as.factor(kmeans_model$cluster)
# 2.4 Visualizar los clusters
fviz_cluster(kmeans_model, data = data_scaled)
# Asignamos nombres a los clusters según el promedio de inundaciones
risk_labels <- DataLimpia %>%
group_by(cluster_risk) %>%
summarise(mean_flood = mean(flood_history)) %>%
arrange(mean_flood)
# Asignamos nombres a los clusters según el promedio de inundacion
# Crear una columna final de riesgo (Bajo, Medio, Alto)
DataLimpia$risk_level <- recode(DataLimpia$cluster_risk,
"1" = "Bajo",
"2" = "Medio",
"3" = "Alto")
DataLimpia$risk_level <- factor(DataLimpia$risk_level, levels = c("Bajo", "Medio", "Alto"))
# 2.1 Determinar número óptimo de clusters con el método del codo
fviz_nbclust(data_scaled, kmeans, method = "wss")
# 2.2 Probar K-Means con k = 3 (o el valor que el gráfico indique)
set.seed(123)
kmeans_model <- kmeans(data_scaled, centers = 3, nstart = 25)
# 2.3 Añadir los clusters al dataset original
DataLimpia$cluster_risk <- as.factor(kmeans_model$cluster)
# 2.4 Visualizar los clusters
fviz_cluster(kmeans_model, data = data_scaled)
# Asignamos nombres a los clusters según el promedio de inundacion
# Crear una columna final de riesgo (Bajo, Medio, Alto)
DataLimpia$risk_level <- recode(DataLimpia$cluster_risk,
"1" = "Bajo",
"2" = "Medio",
"3" = "Alto")
DataLimpia$risk_level <- factor(DataLimpia$risk_level, levels = c("Bajo", "Medio", "Alto"))
# Asignamos nombres a los clusters según el promedio de inundacion
# Crear una columna final de riesgo (Bajo, Medio, Alto)
DataLimpia$risk_level <- recode(DataLimpia$cluster_risk,
"1" = "Bajo",
"2" = "Medio",
"3" = "Alto")
DataLimpia$risk_level <- factor(DataLimpia$risk_level, levels = c("Bajo", "Medio", "Alto"))
library(ggplot2)
ggplot(DataLimpia, aes(x = elevation_m, y = historical_rainfall_intensity_mm_hr, color = risk_level)) +
geom_point() +
labs(title = "Distribución de Riesgo de Inundación por Clúster",
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)") +
theme_minimal()
knitr::opts_chunk$set(fig.crop = FALSE)
