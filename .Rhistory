)
)
cat("\n========== PERFILES DE RIESGO POR CLUSTER ==========\n")
print(cluster_stats %>% select(Cluster, risk_index, risk_level,
elevacion_promedio, lluvia_promedio,
proximidad_drenaje_promedio,
elevation_rain_ratio_promedio))
# Mapear niveles de riesgo a ambos datasets
risk_mapping <- setNames(cluster_stats$risk_level, cluster_stats$Cluster)
DataTransform$risk_level <- risk_mapping[as.character(DataTransform$Cluster)]
DataLimpia$risk_level <- risk_mapping[as.character(DataLimpia$Cluster)]
# Convertir a factor con niveles ordenados
DataTransform$risk_level <- factor(DataTransform$risk_level,
levels = c("Bajo", "Medio", "Alto"))
DataLimpia$risk_level <- factor(DataLimpia$risk_level,
levels = c("Bajo", "Medio", "Alto"))
cat("\n========== MAPEO COMPLETADO ==========\n")
cat("Niveles de riesgo asignados a DataTransform y DataLimpia\n")
# Distribución final
cat("\n========== DISTRIBUCIÓN FINAL POR NIVEL DE RIESGO ==========\n")
print(table(DataLimpia$risk_level))
cat("\nPorcentajes:\n")
print(round(prop.table(table(DataLimpia$risk_level)) * 100, 2))
# Visualización 1: Distribución de riesgo (Elevación vs Lluvia)
ggplot(DataLimpia, aes(x = elevation_m, y = rainfall_winsorizada,
color = risk_level)) +
geom_point(alpha = 0.6, size = 1.5) +
scale_color_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Distribución de Riesgo de Inundación por Cluster",
subtitle = "K-Means con k=3",
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)",
color = "Nivel de Riesgo") +
theme_minimal() +
theme(legend.position = "right",
plot.title = element_text(face = "bold", size = 14))
# Visualización 2: Boxplots comparativos
DataLimpia %>%
select(risk_level, elevation_m, rainfall_winsorizada,
drainage_density_km_per_km2, storm_drain_proximity_winsorizada) %>%
pivot_longer(cols = -risk_level, names_to = "variable", values_to = "value") %>%
ggplot(aes(x = risk_level, y = value, fill = risk_level)) +
geom_boxplot(alpha = 0.7) +
facet_wrap(~variable, scales = "free_y", ncol = 2,
labeller = labeller(variable = c(
"elevation_m" = "Elevación (m)",
"historical_rainfall_intensity_mm_hr" = "Intensidad lluvia (mm/hr)",
"drainage_density_km_per_km2" = "Densidad drenaje (km/km²)",
"storm_drain_proximity_m" = "Proximidad drenaje (m)"
))) +
scale_fill_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Comparación de Variables por Nivel de Riesgo",
x = "Nivel de Riesgo",
y = "Valor") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold", size = 14),
strip.text = element_text(face = "bold"))
# Visualización 3: Barras de distribución
ggplot(DataLimpia, aes(x = risk_level, fill = risk_level)) +
geom_bar(alpha = 0.8) +
geom_text(stat = 'count', aes(label = after_stat(count)),
vjust = -0.5, size = 4, fontface = "bold") +
scale_fill_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Distribución de Registros por Nivel de Riesgo",
x = "Nivel de Riesgo",
y = "Cantidad de registros") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold", size = 14))
# ESTADÍSTICAS FINALES POR NIVEL DE RIESGO
cat("\n========== ESTADÍSTICAS DESCRIPTIVAS POR NIVEL DE RIESGO ==========\n")
# Estadísticas usando datos originales de DataLimpia
stats_finales <- DataLimpia %>%
group_by(risk_level) %>%
summarise(
n = n(),
porcentaje = round(n() / nrow(DataLimpia) * 100, 2),
elevacion_media = round(mean(elevation_m, na.rm = TRUE), 2),
elevacion_sd = round(sd(elevation_m, na.rm = TRUE), 2),
lluvia_media = round(mean(rainfall_winsorizada, na.rm = TRUE), 2),
lluvia_sd = round(sd(rainfall_winsorizada, na.rm = TRUE), 2),
proximidad_drenaje_media = round(mean(storm_drain_proximity_winsorizada, na.rm = TRUE), 2),
densidad_drenaje_media = round(mean(drainage_density_km_per_km2, na.rm = TRUE), 2),
.groups = 'drop'
)
print(stats_finales)
# Estadísticas usando variables transformadas de DataTransform
cat("\n========== ESTADÍSTICAS CON VARIABLES NORMALIZADAS Y DERIVADAS ==========\n")
stats_transform <- DataTransform %>%
group_by(risk_level) %>%
summarise(
n = n(),
elevacion_norm_media = round(mean(norm_elevation_m, na.rm = TRUE), 3),
lluvia_norm_media = round(mean(norm_rainfall_winsorizada, na.rm = TRUE), 3),
elevation_rain_ratio_media = round(mean(elevation_rain_ratio, na.rm = TRUE), 3),
drainage_rain_index_media = round(mean(drainage_rain_index, na.rm = TRUE), 3),
proximity_index_media = round(mean(proximity_index, na.rm = TRUE), 3),
.groups = 'drop'
)
print(stats_transform)
cat("\n========== ANÁLISIS DE CLUSTERING COMPLETADO ==========\n")
cat("Método utilizado: K-Means (k=3)\n")
cat("Coeficiente de Silueta:", round(avg_sil_kmeans, 3), "\n")
cat("Varianza explicada (BSS/TSS):", round(kmeans_model$betweenss / kmeans_model$totss * 100, 2), "%\n")
library(ggplot2)
ggplot(DataLimpia, aes(x = elevation_m, y = rainfall_winsorizada, color = risk_level)) +
geom_point() +
labs(title = "Distribución de Riesgo de Inundación por Clúster",
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)") +
theme_minimal()
# Estadísticas descriptivas por nivel de riesgo
cat("\n========== ESTADÍSTICAS POR NIVEL DE RIESGO ==========\n")
DataLimpia %>%
filter(risk_level != "Sin clasificar") %>%
group_by(risk_level) %>%
summarise(
n = n(),
elevacion_promedio = round(mean(elevation_m, na.rm = TRUE), 2),
lluvia_promedio = round(mean(rainfall_winsorizada, na.rm = TRUE), 2),
proximidad_drenaje = round(mean(storm_drain_proximity_winsorizada, na.rm = TRUE), 2),
.groups = 'drop'
) %>%
print()
cat("\n========== ANÁLISIS DE CLUSTERING COMPLETADO ==========\n")
# Agregar los resultados del clustering a la data original
DataGeo <- DataLimpia %>%
mutate(cluster = kmeans_model$cluster) %>%
select(city_name, admin_ward, latitude, longitude, cluster)
View(DataLimpia)
# Agregar los resultados del clustering a la data original
DataGeo <- DataTransform %>%
mutate(cluster = kmeans_model$cluster) %>%
select(city_name, latitude, longitude, cluster)
View(DataTransform)
knitr::opts_chunk$set(echo = TRUE)
library(formattable)
library(dplyr)
library(tidyverse)
library(readr)
library(ggplot2)
library(scales)
library(knitr)
library(kableExtra)
library(cluster)
library(factoextra)
library(caret)
library(randomForest)
library(fastDummies)
library(DescTools)
library(tinytex)
library(gridExtra)
Data <- read.csv(
"urban_pluvial_flood_risk_dataset.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
# Selección de variables relevantes
DataSeleccion <- Data %>%
select(
city_name,
latitude,
longitude,
elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_m,
historical_rainfall_intensity_mm_hr,
return_period_years,
land_use,
soil_group,
storm_drain_type
)
# Eliminación de registros (filas) con más del 30% de valores NA
DataLimpia <- DataSeleccion %>%
filter(if_all(everything(), ~ !is.na(.)))
# Mostrar cantidad de filas antes y después
nrow(DataSeleccion)
nrow(DataLimpia)
DataLimpia<- DataLimpia %>%
distinct()
# Detección de outliers por Z-score
z_scores <- scale(DataLimpia[, sapply(DataLimpia, is.numeric)])
outliers <- which(abs(z_scores) > 3, arr.ind = TRUE)
# Visualización de posibles outliers
boxplot(DataLimpia$historical_rainfall_intensity_mm_hr, main="Outliers en intensidad de lluvia")
boxplot(DataLimpia$storm_drain_proximity_m,
main = "Boxplot de Distancia a Drenaje (storm_drain_proximity_m)")
#  Eliminar elevaciones negativas
DataLimpia <- DataLimpia[DataLimpia$elevation_m >= 0, ]
#winsorización en la columna de lluvia histórica en una variable nueva rainfall_winsorizada
DataLimpia$rainfall_winsorizada <- DescTools::Winsorize(
DataLimpia$historical_rainfall_intensity_mm_hr,
val = quantile(
DataLimpia$historical_rainfall_intensity_mm_hr,
probs = c(0.01, 0.99),
na.rm = TRUE
)
)
#winsorización en la columna de lluvia histórica en una variable nueva  rainfall_winsorizada
DataLimpia$storm_drain_proximity_winsorizada <- DescTools::Winsorize(
DataLimpia$storm_drain_proximity_m,
val = quantile(
DataLimpia$storm_drain_proximity_m,
probs = c(0.01, 0.99),
na.rm = TRUE
)
)
DataTransform <- DataLimpia %>%
mutate(across(c(elevation_m,
drainage_density_km_per_km2,
storm_drain_proximity_winsorizada,
rainfall_winsorizada,
return_period_years),
~ (.-min(.)) / (max(.)-min(.)),
.names = "norm_{col}"))
DataTransform <- fastDummies::dummy_cols(DataTransform,
select_columns = c("land_use", "soil_group", "storm_drain_type"),
remove_first_dummy = TRUE,
remove_selected_columns = TRUE)
DataTransform <- DataTransform %>%
mutate(
elevation_rain_ratio = norm_elevation_m / (norm_rainfall_winsorizada + 0.001),
drainage_rain_index = norm_drainage_density_km_per_km2 * norm_rainfall_winsorizada,
proximity_index = 1 / (norm_storm_drain_proximity_winsorizada + 0.01)
)
head(DataLimpia %>% select(elevation_m, drainage_density_km_per_km2))
head(DataTransform %>% select(norm_elevation_m, norm_drainage_density_km_per_km2, elevation_rain_ratio))
data_cluster <- DataTransform %>%
select(
norm_elevation_m,
norm_drainage_density_km_per_km2,
norm_storm_drain_proximity_winsorizada,
norm_rainfall_winsorizada,
norm_return_period_years,
elevation_rain_ratio,
drainage_rain_index,
proximity_index,
starts_with("land_use_"),
starts_with("soil_group_"),
starts_with("storm_drain_type_")
)
data_cluster <- data_cluster %>%
select(where(~ !any(is.na(.))))
data_scaled <- scale(data_cluster)
cat("\n========== K-MEANS CLUSTERING ==========\n")
p1 <- fviz_nbclust(data_scaled, kmeans, method = "wss", k.max = 10) +
ggtitle("K-Means: Método del Codo (WSS)")
p2 <- fviz_nbclust(data_scaled, kmeans, method = "silhouette", k.max = 10) +
ggtitle("K-Means: Método de la Silueta")
gridExtra::grid.arrange(p1, p2, ncol = 2)
set.seed(123)
kmeans_model <- kmeans(data_scaled, centers = 3, nstart = 50, iter.max = 100)
sil_kmeans <- silhouette(kmeans_model$cluster, dist(data_scaled))
avg_sil_kmeans <- mean(sil_kmeans[, 3])
cat("K-Means - Clusters:", 3, "\n")
cat("K-Means - Coeficiente de Silueta:", round(avg_sil_kmeans, 3), "\n")
cat("K-Means - BSS/TSS:", round(kmeans_model$betweenss / kmeans_model$totss * 100, 2), "%\n")
fviz_cluster(kmeans_model, data = data_scaled,
geom = "point",
ellipse.type = "convex",
palette = "jco",
main = "K-Means Clustering (k=3)") +
theme_minimal()
cat("\n========== HIERARCHICAL CLUSTERING ==========\n")
# Matriz de distancias
dist_matrix <- dist(data_scaled, method = "euclidean")
# Clustering jerárquico con método Ward
hc_ward <- hclust(dist_matrix, method = "ward.D2")
# Dendrograma
fviz_dend(hc_ward, k = 3,
cex = 0.5,
palette = "jco",
rect = TRUE,
main = "Dendrograma - Clustering Jerárquico (Ward)") +
theme_minimal()
# Método de la Silueta para Jerárquico
p_hc_sil <- fviz_nbclust(data_scaled,
FUN = function(x, k) list(cluster = cutree(hc_ward, k)),
method = "silhouette",
k.max = 10) +
ggtitle("Jerárquico: Método de la Silueta")
print(p_hc_sil)
# Cortar dendrograma en 3 clusters
hc_clusters <- cutree(hc_ward, k = 3)
# Métricas Jerárquico
sil_hc <- silhouette(hc_clusters, dist_matrix)
avg_sil_hc <- mean(sil_hc[, 3])
cat("Jerárquico - Clusters:", 3, "\n")
cat("Jerárquico - Coeficiente de Silueta:", round(avg_sil_hc, 3), "\n")
# Visualización Jerárquico
fviz_cluster(list(data = data_scaled, cluster = hc_clusters),
geom = "point",
ellipse.type = "convex",
palette = "jco",
main = "Clustering Jerárquico Ward (k=3)") +
theme_minimal()
# Verificar que tenemos el mismo número de filas
cat("Filas en data_scaled:", nrow(data_scaled), "\n")
cat("Filas en DataTransform:", nrow(DataTransform), "\n")
cat("Filas en DataLimpia:", nrow(DataLimpia), "\n")
# Asignar clusters a ambos datasets
DataTransform$Cluster <- as.factor(kmeans_model$cluster)
DataLimpia$Cluster <- as.factor(kmeans_model$cluster)
# Verificar la asignación
cat("Clusters asignados correctamente\n")
print(table(DataTransform$Cluster))
# Calcular estadísticas por cluster usando las variables normalizadas
cluster_stats <- DataTransform %>%
group_by(Cluster) %>%
summarise(
n = n(),
elevacion_promedio = mean(norm_elevation_m, na.rm = TRUE),
lluvia_promedio = mean(norm_rainfall_winsorizada, na.rm = TRUE),
proximidad_drenaje_promedio = mean(norm_storm_drain_proximity_winsorizada, na.rm = TRUE),
densidad_drenaje_promedio = mean(norm_drainage_density_km_per_km2, na.rm = TRUE),
periodo_retorno_promedio = mean(norm_return_period_years, na.rm = TRUE),
# También las variables derivadas
elevation_rain_ratio_promedio = mean(elevation_rain_ratio, na.rm = TRUE),
drainage_rain_index_promedio = mean(drainage_rain_index, na.rm = TRUE),
proximity_index_promedio = mean(proximity_index, na.rm = TRUE),
.groups = 'drop'
)
cat("\n========== ESTADÍSTICAS POR CLUSTER ==========\n")
print(cluster_stats)
# Crear índice de riesgo compuesto para cada cluster
cluster_stats <- cluster_stats %>%
mutate(
# Índice de riesgo usando variables normalizadas y derivadas
# Las variables ya están normalizadas (0-1)
risk_index = (1 - elevacion_promedio) * 0.30 +        # Elevación baja aumenta riesgo
lluvia_promedio * 0.25 +                  # Lluvia alta aumenta riesgo
proximidad_drenaje_promedio * 0.20 +      # Lejos de drenaje aumenta riesgo
(1 - drainage_rain_index_promedio) * 0.15 + # Bajo índice drenaje-lluvia aumenta riesgo
(1 - proximity_index_promedio) * 0.10     # Bajo índice proximidad aumenta riesgo
) %>%
arrange(desc(risk_index))
cat("\n========== ÍNDICE DE RIESGO POR CLUSTER ==========\n")
print(cluster_stats %>% select(Cluster, risk_index))
# Asignar nivel de riesgo según el índice
cluster_stats <- cluster_stats %>%
mutate(
risk_level = case_when(
risk_index >= quantile(risk_index, 0.67) ~ "Alto",
risk_index >= quantile(risk_index, 0.33) ~ "Medio",
TRUE ~ "Bajo"
)
)
cat("\n========== PERFILES DE RIESGO POR CLUSTER ==========\n")
print(cluster_stats %>% select(Cluster, risk_index, risk_level,
elevacion_promedio, lluvia_promedio,
proximidad_drenaje_promedio,
elevation_rain_ratio_promedio))
# Mapear niveles de riesgo a ambos datasets
risk_mapping <- setNames(cluster_stats$risk_level, cluster_stats$Cluster)
DataTransform$risk_level <- risk_mapping[as.character(DataTransform$Cluster)]
DataLimpia$risk_level <- risk_mapping[as.character(DataLimpia$Cluster)]
# Convertir a factor con niveles ordenados
DataTransform$risk_level <- factor(DataTransform$risk_level,
levels = c("Bajo", "Medio", "Alto"))
DataLimpia$risk_level <- factor(DataLimpia$risk_level,
levels = c("Bajo", "Medio", "Alto"))
cat("\n========== MAPEO COMPLETADO ==========\n")
cat("Niveles de riesgo asignados a DataTransform y DataLimpia\n")
# Distribución final
cat("\n========== DISTRIBUCIÓN FINAL POR NIVEL DE RIESGO ==========\n")
print(table(DataLimpia$risk_level))
cat("\nPorcentajes:\n")
print(round(prop.table(table(DataLimpia$risk_level)) * 100, 2))
# Visualización 1: Distribución de riesgo (Elevación vs Lluvia)
ggplot(DataLimpia, aes(x = elevation_m, y = rainfall_winsorizada,
color = risk_level)) +
geom_point(alpha = 0.6, size = 1.5) +
scale_color_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Distribución de Riesgo de Inundación por Cluster",
subtitle = "K-Means con k=3",
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)",
color = "Nivel de Riesgo") +
theme_minimal() +
theme(legend.position = "right",
plot.title = element_text(face = "bold", size = 14))
# Visualización 2: Boxplots comparativos
DataLimpia %>%
select(risk_level, elevation_m, rainfall_winsorizada,
drainage_density_km_per_km2, storm_drain_proximity_winsorizada) %>%
pivot_longer(cols = -risk_level, names_to = "variable", values_to = "value") %>%
ggplot(aes(x = risk_level, y = value, fill = risk_level)) +
geom_boxplot(alpha = 0.7) +
facet_wrap(~variable, scales = "free_y", ncol = 2,
labeller = labeller(variable = c(
"elevation_m" = "Elevación (m)",
"historical_rainfall_intensity_mm_hr" = "Intensidad lluvia (mm/hr)",
"drainage_density_km_per_km2" = "Densidad drenaje (km/km²)",
"storm_drain_proximity_m" = "Proximidad drenaje (m)"
))) +
scale_fill_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Comparación de Variables por Nivel de Riesgo",
x = "Nivel de Riesgo",
y = "Valor") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold", size = 14),
strip.text = element_text(face = "bold"))
# Visualización 3: Barras de distribución
ggplot(DataLimpia, aes(x = risk_level, fill = risk_level)) +
geom_bar(alpha = 0.8) +
geom_text(stat = 'count', aes(label = after_stat(count)),
vjust = -0.5, size = 4, fontface = "bold") +
scale_fill_manual(values = c("Bajo" = "#2ecc71",
"Medio" = "#f39c12",
"Alto" = "#e74c3c")) +
labs(title = "Distribución de Registros por Nivel de Riesgo",
x = "Nivel de Riesgo",
y = "Cantidad de registros") +
theme_minimal() +
theme(legend.position = "none",
plot.title = element_text(face = "bold", size = 14))
# ESTADÍSTICAS FINALES POR NIVEL DE RIESGO
cat("\n========== ESTADÍSTICAS DESCRIPTIVAS POR NIVEL DE RIESGO ==========\n")
# Estadísticas usando datos originales de DataLimpia
stats_finales <- DataLimpia %>%
group_by(risk_level) %>%
summarise(
n = n(),
porcentaje = round(n() / nrow(DataLimpia) * 100, 2),
elevacion_media = round(mean(elevation_m, na.rm = TRUE), 2),
elevacion_sd = round(sd(elevation_m, na.rm = TRUE), 2),
lluvia_media = round(mean(rainfall_winsorizada, na.rm = TRUE), 2),
lluvia_sd = round(sd(rainfall_winsorizada, na.rm = TRUE), 2),
proximidad_drenaje_media = round(mean(storm_drain_proximity_winsorizada, na.rm = TRUE), 2),
densidad_drenaje_media = round(mean(drainage_density_km_per_km2, na.rm = TRUE), 2),
.groups = 'drop'
)
print(stats_finales)
# Estadísticas usando variables transformadas de DataTransform
cat("\n========== ESTADÍSTICAS CON VARIABLES NORMALIZADAS Y DERIVADAS ==========\n")
stats_transform <- DataTransform %>%
group_by(risk_level) %>%
summarise(
n = n(),
elevacion_norm_media = round(mean(norm_elevation_m, na.rm = TRUE), 3),
lluvia_norm_media = round(mean(norm_rainfall_winsorizada, na.rm = TRUE), 3),
elevation_rain_ratio_media = round(mean(elevation_rain_ratio, na.rm = TRUE), 3),
drainage_rain_index_media = round(mean(drainage_rain_index, na.rm = TRUE), 3),
proximity_index_media = round(mean(proximity_index, na.rm = TRUE), 3),
.groups = 'drop'
)
print(stats_transform)
cat("\n========== ANÁLISIS DE CLUSTERING COMPLETADO ==========\n")
cat("Método utilizado: K-Means (k=3)\n")
cat("Coeficiente de Silueta:", round(avg_sil_kmeans, 3), "\n")
cat("Varianza explicada (BSS/TSS):", round(kmeans_model$betweenss / kmeans_model$totss * 100, 2), "%\n")
library(ggplot2)
ggplot(DataLimpia, aes(x = elevation_m, y = rainfall_winsorizada, color = risk_level)) +
geom_point() +
labs(title = "Distribución de Riesgo de Inundación por Clúster",
x = "Elevación (m)",
y = "Intensidad de lluvia histórica (mm/hr)") +
theme_minimal()
# Estadísticas descriptivas por nivel de riesgo
cat("\n========== ESTADÍSTICAS POR NIVEL DE RIESGO ==========\n")
DataLimpia %>%
filter(risk_level != "Sin clasificar") %>%
group_by(risk_level) %>%
summarise(
n = n(),
elevacion_promedio = round(mean(elevation_m, na.rm = TRUE), 2),
lluvia_promedio = round(mean(rainfall_winsorizada, na.rm = TRUE), 2),
proximidad_drenaje = round(mean(storm_drain_proximity_winsorizada, na.rm = TRUE), 2),
.groups = 'drop'
) %>%
print()
cat("\n========== ANÁLISIS DE CLUSTERING COMPLETADO ==========\n")
# Agregar los resultados del clustering a la data original
DataGeo <- DataTransform %>%
mutate(cluster = kmeans_model$cluster) %>%
select(city_name, latitude, longitude, cluster)
# Distribución de clusters por ciudad
table(DataGeo$city_name, DataGeo$cluster)
ggplot(DataGeo, aes(x = longitude, y = latitude, color = as.factor(cluster))) +
geom_point(alpha = 0.7, size = 2) +
labs(
title = "Distribución geográfica de los clusters de riesgo",
x = "Longitud",
y = "Latitud",
color = "Cluster"
) +
theme_minimal()
# Distribución de clusters por ciudad
table(DataGeo$city_name, DataGeo$cluster)
# Distribución de clusters por ciudad
table(DataGeo$city_name, DataGeo$cluster)
ggplot(DataGeo, aes(x = longitude, y = latitude, color = as.factor(cluster))) +
geom_point(alpha = 0.7, size = 2) +
labs(
title = "Distribución geográfica de los clusters de riesgo",
x = "Longitud",
y = "Latitud",
color = "Cluster"
) +
theme_minimal()
knitr::opts_chunk$set(echo = FALSE)
head(DataLimpia %>% select(elevation_m, drainage_density_km_per_km2))
head(DataTransform %>% select(norm_elevation_m, norm_drainage_density_km_per_km2, elevation_rain_ratio))
